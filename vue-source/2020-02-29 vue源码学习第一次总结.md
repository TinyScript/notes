索引：
1. 组件的watcher、$watch的watcher、computed的watcher源码逻辑
2. 依赖收集的源码逻辑
3. 计算属性函数什么时候才会调用源码逻辑

### 组件的watcher、$watch的watcher、computed的watcher源码逻辑：

vue在每次给data定义的属性赋值时，都会触发Object.defineProperty的set拦截器，修改被赋值的value，然后调用当前属性的对应的dep.nofity函数，notify会让所有观察这个属性的watcher对象进行watcher.update。

watcher.update执行后，会调用queueWatcher，将观察者塞入一个数组然后交给异步队列，等到主线程所有赋值都执行完毕以后再处理watcher的更新。

到了异步队列，会遍历处理watcher数组，$watch的watcher和vue组件watcher会在run()的时候调用callback时更新。

而computed的watcher则会在vue组件的watcher执行callback后，执行updateComponent时，所有模板上的属性都会被get拦截器拦截，包括computed在模板上的属性也会触发自己独特的get拦截器进行更新。所以computed是一次被动的更新，需要等待组件watcher执行callback更新后，computed的watcher才会更新。

### 依赖收集的源码逻辑：

普通的属性：在模板中在updateComponent在调用this._render函数时会渲染，渲染时会调用之前parseAST + generate生成好的函数代码，在调用的过程中会访问对应的属性，然后触发对象get拦截器，在拦截器中就会调用dep.depend()，然后让组件watcher收集这个依赖。

$watch：在initWatch时，会执行new Watcher，在实例化watcher的过程中根据传入的key传给parsePath，生成一个查询当前组件属性的匿名函数存储在watcher.getter，然后在watcher.get调用，在查询的过程中就会对属性一一的访问，触发属性的get拦截器，调用dep.depend。因为此时正在$watch的watcher.get()执行过程中，此时key对应的dep会被$watch的watcher收集。

computed：在组件初始化的过程中执行initComputed会创建watcher，但是computed会传dirty = lazy = true，所以不会立刻执行get函数。到了组件的watcher调用updateComponent时，会对模板上的普通属性与computed属性都进行访问，此时就会触发computed的get拦截器，然后会先对计算属性进行脏处理即调用evaluate函数，执行watcher.get后再调用computed的key对应的函数，调用过程中会收集函数内部的所有普通属性依赖，再调用watcher.depend()，让自己所有的依赖都与组件watcher依赖进行同步。综上所述，1. 在脏处理时会收集依赖，2. 脏处理完把自己收集的依赖同步给组件watcher。

### 计算属性函数什么时候才会调用源码逻辑：

在做this.a = 111赋值时，会触发Object.defineProperty的set拦截器，拦截器会在执行赋值成功后调用a属性对应的dep.notify通知。此时收集了a属性dep的watcher则会全部调用update函数，一般来说这个notify会让 组件、$watch、computed三个watcher都会受到影响，只要是你注册过$watch和computed都会有影响。

组件update是为了执行watcher.run()更新组件，去触发reactiveGetter和computedGetter；$watch也是为了执行watcher.run()，去触发注册过的$watch函数；而computed是为了告诉当前watcher有东西改动，但是不会立刻执行任何东西，不会塞入queueWatcher。

等到queueWatcher执行了，组件update执行到watcher.run时调用updateComponent，访问模板中的属性时触发computedGetter，才触发computed watcher的数据更新，最后返回给vue模板使用。

### vue源码读后感

在vue源码中，学会了订阅发布模式，上升到框架层面，可以通过让使用者注册回调的形式去控制最终展现的设计方式。只要是展现端有的内容，就派出观察者去监听（又或者说让展现端的内容去广播处注册），并且也注册了变更回调函数。只要展现端的内容有所变更就触发对应的回调变更函数。

而针对依赖收集需要先访问再收集也很符合现实，比如租房总有户口调查登记。先访问属性再收集依赖，就好比登记员会先去住户家里敲门访问，再记录住户信息。此时住户就是属性，依赖就是住户信息以及电话号码等，而登记员就是watcher。假设有一户人发现房子的线路太老旧了想要变更，就告诉了登记员，此时就是notify的过程。登记员收到了通知，就要对房子进行更新，此时就会触发update。

至于update之后的时就复杂了，对于vue而言就是排序需要更新的watcher，最终的目的都是为了执行watcher.run。而run就是为了执行watcher注册的callback。

然后执行updateComponent进行组件的更新，执行vm._render函数。

收集依赖的过程，就是订阅的过程，因为最终是由依赖进行notify广播。